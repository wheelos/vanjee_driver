/*********************************************************************************************************************
Copyright (c) 2023 Vanjee
All rights reserved

By downloading, copying, installing or using the software you agree to this
license. If you do not agree to this license, do not download, install, copy or
use the software.

License Agreement
For Vanjee LiDAR SDK Library
(3-clause BSD License)

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the names of the Vanjee, nor Suteng Innovation Technology, nor the
names of other contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*********************************************************************************************************************/

#pragma once
#include <mutex>
#include <unordered_map>

#include <vanjee_driver/driver/decoder/wlr760/decoder/one_point_info_manage.hpp>

#ifdef ENABLE_TBB

#include "tbb/blocked_range.h"
#include "tbb/parallel_for.h"

#endif

namespace vanjee {
namespace lidar {
class Filterate760 {
 private:
  static Filterate760* _;
  static std::mutex this_mutex_;

  Trigon trigon_;

  bool algorithm_enable_ = false;
  bool triple_three_filter_enb = false;
  bool replenish_point_enb = false;
  bool ps_crosstalk_filter_enb = false;

  const unsigned short max_line_id = 192;

  std::unordered_map<int, int> cluster_index;

  std::vector<int32_t> ver_angle_type1_ = std::vector<int32_t>{
      12500,  12369,  12238,  12107,  11976,  11846,  11715,  11584,  11453,  11322,  11191,  11060,  10929,  10798,  10668,  10537,  10406,  10275,
      10144,  10013,  9882,   9751,   9620,   9490,   9359,   9228,   9097,   8966,   8835,   8704,   8573,   8442,   8312,   8181,   8050,   7919,
      7788,   7657,   7526,   7395,   7264,   7134,   7003,   6872,   6741,   6610,   6479,   6348,   6217,   6086,   5955,   5825,   5694,   5563,
      5432,   5301,   5170,   5039,   4908,   4777,   4647,   4516,   4385,   4254,   4123,   3992,   3861,   3730,   3599,   3469,   3338,   3207,
      3076,   2945,   2814,   2683,   2552,   2421,   2291,   2160,   2029,   1898,   1767,   1636,   1505,   1374,   1243,   1113,   982,    851,
      720,    589,    458,    327,    196,    65,     -65,    -196,   -327,   -458,   -589,   -720,   -851,   -982,   -1113,  -1243,  -1374,  -1505,
      -1636,  -1767,  -1898,  -2029,  -2160,  -2291,  -2421,  -2552,  -2683,  -2814,  -2945,  -3076,  -3207,  -3338,  -3469,  -3599,  -3730,  -3861,
      -3992,  -4123,  -4254,  -4385,  -4516,  -4647,  -4777,  -4908,  -5039,  -5170,  -5301,  -5432,  -5563,  -5694,  -5825,  -5955,  -6086,  -6217,
      -6348,  -6479,  -6610,  -6741,  -6872,  -7003,  -7134,  -7264,  -7395,  -7526,  -7657,  -7788,  -7919,  -8050,  -8181,  -8312,  -8442,  -8573,
      -8704,  -8835,  -8966,  -9097,  -9228,  -9359,  -9490,  -9620,  -9751,  -9882,  -10013, -10144, -10275, -10406, -10537, -10668, -10798, -10929,
      -11060, -11191, -11322, -11453, -11584, -11715, -11846, -11976, -12107, -12238, -12369, -12500};

  std::vector<int32_t> ver_angle_type2_ = std::vector<int32_t>{
      12500, 12237, 11974,  11711,  11447,  11184,  10921,  10658,  10395,  10132,  9868,   9605,  9342,  9079,  8816,  8553,  8289,  8026,
      7763,  7500,  7237,   6974,   6711,   6447,   6250,   6184,   6118,   5987,   5921,   5855,  5724,  5658,  5592,  5461,  5395,  5329,
      5197,  5132,  5066,   4934,   4868,   4803,   4671,   4605,   4539,   4408,   4342,   4276,  4145,  4079,  4013,  3882,  3816,  3750,
      3618,  3553,  3487,   3355,   3289,   3224,   3092,   3026,   2961,   2829,   2763,   2697,  2566,  2500,  2434,  2303,  2237,  2171,
      2039,  1974,  1908,   1776,   1711,   1645,   1513,   1447,   1382,   1250,   1184,   1118,  987,   921,   855,   724,   658,   592,
      461,   395,   329,    197,    132,    66,     -66,    -132,   -197,   -329,   -395,   -461,  -592,  -658,  -724,  -855,  -921,  -987,
      -1118, -1184, -1250,  -1382,  -1447,  -1513,  -1645,  -1711,  -1776,  -1908,  -1974,  -2039, -2171, -2237, -2303, -2434, -2500, -2566,
      -2697, -2763, -2829,  -2961,  -3026,  -3092,  -3224,  -3289,  -3355,  -3487,  -3553,  -3618, -3750, -3816, -3882, -4013, -4079, -4145,
      -4276, -4342, -4408,  -4539,  -4605,  -4671,  -4803,  -4868,  -4934,  -5066,  -5132,  -5197, -5329, -5395, -5461, -5592, -5658, -5724,
      -5855, -5921, -5987,  -6118,  -6184,  -6250,  -6447,  -6711,  -6974,  -7237,  -7500,  -7763, -8026, -8289, -8553, -8816, -9079, -9342,
      -9605, -9868, -10132, -10395, -10658, -10921, -11184, -11447, -11711, -11974, -12237, -12500};

  std::unordered_map<int, int> IMX459_linetopixel_ = {
      {191, 95}, {190, 94}, {189, 93}, {188, 92}, {187, 91}, {186, 90}, {185, 89}, {184, 88}, {183, 87}, {182, 86}, {181, 85}, {180, 84},
      {179, 83}, {178, 82}, {177, 81}, {176, 80}, {175, 79}, {174, 78}, {173, 77}, {172, 76}, {171, 75}, {170, 74}, {169, 73}, {168, 72},
      {166, 71}, {163, 70}, {160, 69}, {157, 68}, {154, 67}, {151, 66}, {148, 65}, {145, 64}, {142, 63}, {139, 62}, {136, 61}, {133, 60},
      {130, 59}, {127, 58}, {124, 57}, {121, 56}, {118, 55}, {115, 54}, {112, 53}, {109, 52}, {106, 51}, {103, 50}, {100, 49}, {97, 48},
      {94, 47},  {91, 46},  {88, 45},  {85, 44},  {82, 43},  {79, 42},  {76, 41},  {73, 40},  {70, 39},  {67, 38},  {64, 37},  {61, 36},
      {58, 35},  {55, 34},  {52, 33},  {49, 32},  {46, 31},  {43, 30},  {40, 29},  {37, 28},  {34, 27},  {31, 26},  {28, 25},  {25, 24},
      {23, 23},  {22, 22},  {21, 21},  {20, 20},  {19, 19},  {18, 18},  {17, 17},  {16, 16},  {15, 15},  {14, 14},  {13, 13},  {12, 12},
      {11, 11},  {10, 10},  {9, 9},    {8, 8},    {7, 7},    {6, 6},    {5, 5},    {4, 4},    {3, 3},    {2, 2},    {1, 1},    {0, 0}};

  std::unordered_map<int, int> IMX459_pixeltoline_ = {
      {95, 191}, {94, 190}, {93, 189}, {92, 188}, {91, 187}, {90, 186}, {89, 185}, {88, 184}, {87, 183}, {86, 182}, {85, 181}, {84, 180},
      {83, 179}, {82, 178}, {81, 177}, {80, 176}, {79, 175}, {78, 174}, {77, 173}, {76, 172}, {75, 171}, {74, 170}, {73, 169}, {72, 168},
      {71, 166}, {70, 163}, {69, 160}, {68, 157}, {67, 154}, {66, 151}, {65, 148}, {64, 145}, {63, 142}, {62, 139}, {61, 136}, {60, 133},
      {59, 130}, {58, 127}, {57, 124}, {56, 121}, {55, 118}, {54, 115}, {53, 112}, {52, 109}, {51, 106}, {50, 103}, {49, 100}, {48, 97},
      {47, 94},  {46, 91},  {45, 88},  {44, 85},  {43, 82},  {42, 79},  {41, 76},  {40, 73},  {39, 70},  {38, 67},  {37, 64},  {36, 61},
      {35, 58},  {34, 55},  {33, 52},  {32, 49},  {31, 46},  {30, 43},  {29, 40},  {28, 37},  {27, 34},  {26, 31},  {25, 28},  {24, 25},
      {23, 23},  {22, 22},  {21, 21},  {20, 20},  {19, 19},  {18, 18},  {17, 17},  {16, 16},  {15, 15},  {14, 14},  {13, 13},  {12, 12},
      {11, 11},  {10, 10},  {9, 9},    {8, 8},    {7, 7},    {6, 6},    {5, 5},    {4, 4},    {3, 3},    {2, 2},    {1, 1},    {0, 0}};

 public:
  std::vector<std::vector<int32_t>> offset_hor_angle_ = std::vector<std::vector<int32_t>>{
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

  std::vector<std::vector<int32_t>> offset_ver_angle_ = std::vector<std::vector<int32_t>>{
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

  Filterate760();
  static Filterate760* GetInstance();

  void setAlgorithmEnb(bool val) {
    algorithm_enable_ = val;
  }

  void settripleThreeFilterEnb(bool val) {
    triple_three_filter_enb = val;
  }

  void setReplenishPointEnb(bool val) {
    replenish_point_enb = val;
  }

  void psCrosstalkFilterEnb(bool val) {
    ps_crosstalk_filter_enb = val;
  }

  void filter(OnePointInfoManage760& points, uint16_t operate_frequency, bool single, uint8_t publish_mode, uint16_t hor_resolution,
              int32_t max_angle);

 private:
  int getQueryLine(int p_line, int index, bool single);
  uint32_t create_index(uint8_t echo_type, uint16_t line_id, int32_t hor_angle_index);
  int32_t getTimeSequenceOffsetHorAngle(float speed, int line);
  double plane(ClusterItem& points);
  bool canBeClustered(const OnePointInfo760* p1, const OnePointInfo760* p2, float th);
  std::vector<ClusterItem> voxelCluster(OnePointInfoManage760& resGrid, int expand_th, double width_th, double heigth, bool all, bool single,
                                        uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle);

  void tripleThreeFilter(OnePointInfoManage760& points, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle);
  void highReflectiveInter(OnePointInfoManage760& points, bool single, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle);
  void replenishPoint(OnePointInfoManage760& points, int dis_th, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle);
  void ps_crosstalk_replenish(OnePointInfoManage760& points, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle);
};
Filterate760* Filterate760::_;
std::mutex Filterate760::this_mutex_;

Filterate760::Filterate760() {
}

Filterate760* Filterate760::GetInstance() {
  if (_ == nullptr) {
    std::unique_lock<std::mutex> lock(this_mutex_);  // 加锁
    if (_ == nullptr) {
      auto temp = new (std::nothrow) Filterate760();
      _ = temp;
    }
  }
  return _;
}

inline int Filterate760::getQueryLine(int point_line, int index, bool single) {
  int out_line = -1;
  auto _pixel = IMX459_linetopixel_[point_line - 1];
  auto _next_pixel_iter = IMX459_pixeltoline_.find(_pixel + (index));
  if (single) {
    out_line = point_line + index;
  } else {
    if (_next_pixel_iter != IMX459_pixeltoline_.end())
      out_line = _next_pixel_iter->second + 1;
  }
  return out_line;
}

inline uint32_t Filterate760::create_index(uint8_t echo_type, uint16_t line_id, int32_t hor_angle_index) {
  if (echo_type == 1) {
    return ((line_id - 1) * MAX_COL_NUM_760) + hor_angle_index;
  } else if (echo_type == 2) {
    return ((line_id - 1) * MAX_COL_NUM_760) + hor_angle_index;
  } else {
    return 0;
  }
}

inline int32_t Filterate760::getTimeSequenceOffsetHorAngle(float speed, int line) {
  int32_t h_offset = 0;
  if ((line >= 25 && line <= 48) || (line >= 169 && line <= 192)) {
    h_offset = speed * 126 * 1e-3;  // speed * 6 * 7 * 3 * 1e-3;   //18.9e-3
  } else if ((line >= 73 && line <= 96) || (line >= 121 && line <= 144)) {
    h_offset = speed * 252 * 1e-3;  // speed * 6 * 14 * 3 * 1e-3;    //37.8e-3
  } else if ((line >= 49 && line <= 72) || (line >= 97 && line <= 120)) {
    h_offset = speed * 216 * 1e-3;  // speed * 6 * 12 * 3 * 1e-3;    //32.4e-3
  } else if ((line >= 1 && line <= 24) || (line >= 145 && line <= 168)) {
    h_offset = speed * 342 * 1e-3;  // speed * 6 * 19 * 3 * 1e-3;    //51.3e-3
  }
  return h_offset;
}

inline void Filterate760::filter(OnePointInfoManage760& points, uint16_t operate_frequency, bool single, uint8_t publish_mode,
                                 uint16_t hor_resolution, int32_t max_angle) {
  double max_distance = 200.0;

  if (!algorithm_enable_)
    return;

  if (triple_three_filter_enb) {
    if (publish_mode == 2) {
      tripleThreeFilter(points, 1, hor_resolution, max_angle);
      tripleThreeFilter(points, 2, hor_resolution, max_angle);
    } else {
      tripleThreeFilter(points, publish_mode + 1, hor_resolution, max_angle);
    }
  }

  if (replenish_point_enb) {
    if (publish_mode == 2) {
#ifdef ENABLE_TRANSFORM
      highReflectiveInter(points, 1, single, hor_resolution, max_angle);
      highReflectiveInter(points, 2, single, hor_resolution, max_angle);
#endif
      replenishPoint(points, max_distance, 1, hor_resolution, max_angle);
      replenishPoint(points, max_distance, 2, hor_resolution, max_angle);
    } else {
#ifdef ENABLE_TRANSFORM
      highReflectiveInter(points, publish_mode + 1, single, hor_resolution, max_angle);
#endif
      replenishPoint(points, max_distance, publish_mode + 1, hor_resolution, max_angle);
    }
  }

  if (ps_crosstalk_filter_enb) {
    if (publish_mode == 2) {
      ps_crosstalk_replenish(points, 1, hor_resolution, max_angle);
      ps_crosstalk_replenish(points, 2, hor_resolution, max_angle);
    } else {
      ps_crosstalk_replenish(points, publish_mode + 1, hor_resolution, max_angle);
    }
  }
}

inline void Filterate760::tripleThreeFilter(OnePointInfoManage760& points, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle) {
  const int around_th = 2;
  const int dis_th = 3;
  // const int hor_resolution = 15;
#ifdef ENABLE_TBB
  tbb::parallel_for(tbb::blocked_range<int>(1, 193), [&](tbb::blocked_range<int> r) {
    for (int line = r.begin(); line != r.end(); ++line)
#endif
#ifndef ENABLE_TBB
      for (int line = 1; line <= 192; ++line)
#endif
      {
        int line_start = 0, line_end = 0;
        if (line - around_th < 1) {
          line_start = line;
          line_end = line + around_th * 2;
        } else if (line + around_th > 192) {
          line_start = line - around_th * 2;
          line_end = line;
        } else {
          line_start = line - around_th;
          line_end = line + around_th;
        }

        for (int angle = 0; angle < max_angle; angle += hor_resolution) {
          auto& point = points.getData(echo_num, line, angle / hor_resolution);

          if (point.line_id == 0 || point.distance == 0)
            continue;

          /* 噪点滤除策略 2024.09.05 */
          int max_search = 2;
          if (angle > hor_resolution * max_search && angle < max_angle - hor_resolution * max_search) {
            bool flag = false;
            for (int i = 1; i <= max_search; i++) {
              auto& pre_point = points.getData(echo_num, line, (angle - hor_resolution * i) / hor_resolution);
              auto& next_point = points.getData(echo_num, line, (angle + hor_resolution * i) / hor_resolution);
              if (((pre_point.distance == 0) || (std::abs(point.distance - pre_point.distance) > 3.0)) &&
                  ((next_point.distance == 0) || (std::abs(point.distance - next_point.distance) > 3.0)) && (point.distance < 30.0)) {
                flag = true;
              } else {
                flag = false;
                break;
              }
            }
            if (flag)
              point.non_filterable = 6;
          }
          /* 噪点滤除策略 2024.09.13 */
          if (line > max_search && line < 192 - max_search) {
            bool flag = false;
            for (int i = 1; i <= max_search; i++) {
              auto& pre_line_point = points.getData(echo_num, line - i, angle / hor_resolution);
              auto& next_line_point = points.getData(echo_num, line + i, angle / hor_resolution);
              if (((pre_line_point.distance == 0) || (std::abs(point.distance - pre_line_point.distance)) > 3.0) &&
                  ((next_line_point.distance == 0) || (std::abs(point.distance - next_line_point.distance)) > 3.0) && (point.distance < 10.0)) {
                flag = true;
              } else {
                flag = false;
                break;
              }
            }
            if (flag)
              point.non_filterable = 6;
          }

          int angle_start = 0, angle_end = 0;
          if (angle - (hor_resolution * around_th) < 0) {
            angle_start = angle;
            angle_end = angle + ((hor_resolution * around_th) * 2);
          } else if (angle + (hor_resolution * around_th) >= max_angle) {
            angle_start = angle - ((hor_resolution * around_th) * 2);
            angle_end = angle;
          } else {
            angle_start = angle - (hor_resolution * around_th);
            angle_end = angle + (hor_resolution * around_th);
          }

          int cn = 0;
          for (int q_line = line_start; q_line <= line_end; q_line++) {
            for (int q_angle = angle_start; q_angle <= angle_end; q_angle += hor_resolution) {
              auto& p = points.getData(echo_num, q_line, q_angle / hor_resolution);
              if (p.line_id == 0 || p.distance == 0)
                continue;

              // if (point.index != p.index && std::sqrt(std::pow(point.x -
              // p.x, 2) + std::pow(point.y - p.y, 2) + std::pow(point.z -
              // p.z, 2)) < dis_th)
              //     cn++;
              int xpow = ((int)point.x - (int)p.x) * ((int)point.x - (int)p.x);
              int ypow = ((int)point.y - (int)p.y) * ((int)point.y - (int)p.y);
              int zpow = ((int)point.z - (int)p.z) * ((int)point.z - (int)p.z);
              if (point.index != p.index && (xpow + ypow + zpow) < dis_th * dis_th)
                cn++;
              if (point.distance < 5.0) {
                if (cn > 3) {
                  goto EXIT;
                }
              } else {
                if (cn > 1) {
                  goto EXIT;
                }
              }
            }
          }

          if (point.distance < 5.0) {
            if (cn < 4 && point.non_filterable == 0) {
              point.non_filterable = 6;
            }
          } else {
            if (cn < 2 && point.non_filterable == 0) {
              point.non_filterable = 6;
            }
          }

        EXIT:;
        }
      }
#ifdef ENABLE_TBB
  });
#endif
}

#ifdef ENABLE_TRANSFORM
#if true

double Filterate760::plane(ClusterItem& points) {
  double meanx = 0, meany = 0, meanz = 0;
  int Neff = 0;
  for (size_t iiii = 0; iiii < points.item.size(); iiii += 1) {
    {
      meanx += points.item[iiii]->x;
      meany += points.item[iiii]->y;
      meanz += points.item[iiii]->z;
      ++Neff;
    }
  }

  meanx = meanx / Neff;
  meany = meany / Neff;
  meanz = meanz / Neff;
  double sumxx = 0, sumyy = 0, sumzz = 0, sumxy = 0, sumxz = 0, sumyz = 0;
  for (size_t jj = 0; jj < points.item.size(); jj += 1) {
    {
      sumxx += (points.item[jj]->x - meanx) * (points.item[jj]->x - meanx);
      sumyy += (points.item[jj]->y - meany) * (points.item[jj]->y - meany);
      sumzz += (points.item[jj]->z - meanz) * (points.item[jj]->z - meanz);
      sumxy += (points.item[jj]->x - meanx) * (points.item[jj]->y - meany);
      sumxz += (points.item[jj]->x - meanx) * (points.item[jj]->z - meanz);
      sumyz += (points.item[jj]->y - meany) * (points.item[jj]->z - meanz);
    }
  }
  Eigen::Matrix3d A;
  A << sumxx, sumxy, sumxz, sumxy, sumyy, sumyz, sumxz, sumyz, sumzz;

  // Eigen::EigenSolver<Eigen::Matrix3d> es(A);
  // Eigen::Matrix3d D = es.pseudoEigenvalueMatrix();
  // Eigen::Matrix3d V = es.pseudoEigenvectors();

  Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);
  Eigen::Matrix3d V = svd.matrixV();
  Eigen::MatrixXd U = svd.matrixU();

  Eigen::Vector3d res;
  res.x() = V(0, 2);
  res.y() = V(1, 2);
  res.z() = V(2, 2);
  res.normalize();

  double d = -(res.x() * meanx + res.y() * meany + res.z() * meanz);

  double dis = 0;
  for (auto& p : points.item) {
    dis += std::pow(d + (res.x() * p->x + res.y() * p->y + res.z() * p->z), 2);
  }
  dis /= points.item.size();

  if (std::abs(res.z()) > 0.5)
    dis = 1;
  return dis;
}

inline bool Filterate760::canBeClustered(const OnePointInfo760* p1, const OnePointInfo760* p2, float th) {
  // if (p2->cluster_index == 0 && p2->reflectivity == 255)
  //   return std::pow(p1->x - p2->x, 2) + std::pow(p1->y - p2->y, 2) + std::pow(p1->z - p2->z, 2) < th;
  // else
  //   return false;

  if (p2->hor_azimuth < 2000 || p2->hor_azimuth > 10000) {
    if (cluster_index.find(p2->index) == cluster_index.end() && p2->reflectivity == 255)
      return std::pow(p1->x - p2->x, 2) + std::pow(p1->y - p2->y, 2) + std::pow(p1->z - p2->z, 2) < th;
    else
      return false;
  } else if ((cluster_index.find(p2->index) == cluster_index.end() && (p2->reflectivity == 255))) {
    return std::pow(p1->x - p2->x, 2) + std::pow(p1->y - p2->y, 2) + std::pow(p1->z - p2->z, 2) < th;
  }

  return false;
}

inline std::vector<ClusterItem> Filterate760::voxelCluster(OnePointInfoManage760& resGrid, int expand_th, double width_th, double heigth, bool all,
                                                           bool single, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle) {
  std::vector<ClusterItem> res;
  std::vector<OnePointInfo760*> outlier;
  std::vector<OnePointInfo760*> new_outlier;
  cluster_index.clear();
  int clusters_id = 0;
  float dis_th = 1;
  // int expand_th = 1;

  for (int line = 1; line <= max_line_id; line++) {
    if (!single && IMX459_linetopixel_.find(line) == IMX459_linetopixel_.end())
      continue;
    for (int angle = 0; angle < max_angle; angle += hor_resolution) {
      ClusterItem item;
      {
        auto& p = resGrid.getData(echo_num, line, angle / hor_resolution);
        if (p.reflectivity != 255 || cluster_index.find(p.index) != cluster_index.end() /*p.cluster_index != 0*/ || p.line_id == 0 ||
            p.non_filterable != 0)
          continue;

        clusters_id++;
        cluster_index[p.index] = clusters_id;
        // p.cluster_index = clusters_id;
        outlier.push_back(&p);
        item.item.push_back(&p);
        item.left = p.x;
        item.rigth = p.x;
        item.up = p.z;
        item.down = p.z;
      }
      int32_t max_col_num = max_angle / hor_resolution;
      for (int q = 0; q < max_col_num; q++) {
        for (size_t index = 0; index < outlier.size(); index++) {
          auto p = outlier[index];
          dis_th = p->distance < 100 ? 1 : p->distance / 100.0;
          dis_th = dis_th * dis_th;
          int p_line = p->line_id;
          int p_angle = p->hor_azimuth;
          for (int e = 0; e <= expand_th; e++) {
            int q_angle = p_angle - (e + 1) * hor_resolution;
            // int q_line = p_line + (e + 1);
            int q_line = getQueryLine(p_line, e + 1, single);
            if (q_angle < 0)
              break;
            if (q_line > max_line_id || q_line < 1)
              break;
            auto& p_down = resGrid.getData(echo_num, q_line, p_angle / hor_resolution);
            if (canBeClustered(p, &p_down, dis_th)) {
              cluster_index[p_down.index] = clusters_id;
              // p_down.cluster_index = clusters_id;
              new_outlier.push_back(&p_down);
              if (p_down.x < item.left)
                item.left = p_down.x;
              if (p_down.x > item.rigth)
                item.rigth = p_down.x;
              if (p_down.z < item.down)
                item.down = p_down.z;
              if (p_down.z > item.up)
                item.up = p_down.z;

              // goto SPIK;
              break;
            } else {
              if (q_line > max_line_id)
                break;
              auto& p_left_down = resGrid.getData(echo_num, q_line, q_angle / hor_resolution);
              if (canBeClustered(p, &p_left_down, dis_th)) {
                cluster_index[p_left_down.index] = clusters_id;
                // p_left_down.cluster_index = clusters_id;
                new_outlier.push_back(&p_left_down);
                if (p_left_down.x < item.left)
                  item.left = p_left_down.x;
                if (p_left_down.x > item.rigth)
                  item.rigth = p_left_down.x;
                if (p_left_down.z < item.down)
                  item.down = p_left_down.z;
                if (p_left_down.z > item.up)
                  item.up = p_left_down.z;
                break;
              }
            }
          }

          if (all) {
            for (int e = 0; e <= expand_th; e++) {
              int q_angle = p_angle - (e + 1) * hor_resolution;
              if (q_angle < 0 || q_angle >= max_angle)
                break;
              auto& p_left = resGrid.getData(echo_num, p_line, q_angle / hor_resolution);
              if (canBeClustered(p, &p_left, dis_th)) {
                cluster_index[p_left.index] = clusters_id;
                // p_left.cluster_index = clusters_id;
                new_outlier.push_back(&p_left);
                if (p_left.x < item.left)
                  item.left = p_left.x;
                if (p_left.x > item.rigth)
                  item.rigth = p_left.x;
                if (p_left.z < item.down)
                  item.down = p_left.z;
                if (p_left.z > item.up)
                  item.up = p_left.z;
                break;
              } else {
                // int q_line = p_line - (e + 1);
                int q_line = getQueryLine(p_line, -(e + 1), single);
                if (q_line < 1)
                  break;
                auto& p_left_up = resGrid.getData(echo_num, q_line, q_angle / hor_resolution);
                if (canBeClustered(p, &p_left_up, dis_th)) {
                  cluster_index[p_left_up.index] = clusters_id;
                  // p_left_up.cluster_index = clusters_id;
                  new_outlier.push_back(&p_left_up);
                  if (p_left_up.x < item.left)
                    item.left = p_left_up.x;
                  if (p_left_up.x > item.rigth)
                    item.rigth = p_left_up.x;
                  if (p_left_up.z < item.down)
                    item.down = p_left_up.z;
                  if (p_left_up.z > item.up)
                    item.up = p_left_up.z;
                  break;
                }
              }
            }
          }

          for (int e = 0; e <= expand_th; e++) {
            // int q_line = p_line - (e + 1);
            int q_line = getQueryLine(p_line, -(e + 1), single);
            if (q_line < 1)
              break;
            auto& p_up = resGrid.getData(echo_num, q_line, p_angle / hor_resolution);
            if (canBeClustered(p, &p_up, dis_th)) {
              cluster_index[p_up.index] = clusters_id;
              // p_up.cluster_index = clusters_id;
              new_outlier.push_back(&p_up);
              if (p_up.x < item.left)
                item.left = p_up.x;
              if (p_up.x > item.rigth)
                item.rigth = p_up.x;
              if (p_up.z < item.down)
                item.down = p_up.z;
              if (p_up.z > item.up)
                item.up = p_up.z;
              break;
            } else {
              int q_angle = p_angle + (e + 1) * hor_resolution;
              if (q_angle < 0 || q_angle >= max_angle)
                break;
              auto& p_right_up = resGrid.getData(echo_num, q_line, q_angle / hor_resolution);
              if (canBeClustered(p, &p_right_up, dis_th)) {
                cluster_index[p_right_up.index] = clusters_id;
                // p_right_up.cluster_index = clusters_id;
                new_outlier.push_back(&p_right_up);
                if (p_right_up.x < item.left)
                  item.left = p_right_up.x;
                if (p_right_up.x > item.rigth)
                  item.rigth = p_right_up.x;
                if (p_right_up.z < item.down)
                  item.down = p_right_up.z;
                if (p_right_up.z > item.up)
                  item.up = p_right_up.z;
                break;
              }
            }
          }

          if (all) {
            for (int e = 0; e <= expand_th; e++) {
              int q_angle = p_angle + (e + 1) * hor_resolution;
              if (q_angle < 0 || q_angle >= max_angle)
                break;

              auto& p_right = resGrid.getData(echo_num, p_line, q_angle / hor_resolution);
              if (canBeClustered(p, &p_right, dis_th)) {
                cluster_index[p_right.index] = clusters_id;
                // p_right.cluster_index = clusters_id;
                new_outlier.push_back(&p_right);
                if (p_right.x < item.left)
                  item.left = p_right.x;
                if (p_right.x > item.rigth)
                  item.rigth = p_right.x;
                if (p_right.z < item.down)
                  item.down = p_right.z;
                if (p_right.z > item.up)
                  item.up = p_right.z;
                break;
              } else {
                // int q_line = p_line + (e + 1);
                int q_line = getQueryLine(p_line, e + 1, single);
                if (q_line > max_line_id)
                  break;
                auto& p_right_up = resGrid.getData(echo_num, q_line, q_angle / hor_resolution);
                if (canBeClustered(p, &p_right_up, dis_th)) {
                  cluster_index[p_right_up.index] = clusters_id;
                  // p_right_up.cluster_index = clusters_id;
                  new_outlier.push_back(&p_right_up);
                  if (p_right_up.x < item.left)
                    item.left = p_right_up.x;
                  if (p_right_up.x > item.rigth)
                    item.rigth = p_right_up.x;
                  if (p_right_up.z < item.down)
                    item.down = p_right_up.z;
                  if (p_right_up.z > item.up)
                    item.up = p_right_up.z;
                  break;
                }
              }
            }
          }
        }
        outlier = new_outlier;
        new_outlier.clear();
        if (outlier.empty()) {
          break;
        }
        item.item.insert(item.item.end(), outlier.begin(), outlier.end());
        // item.item = outlier;
      }

      double res_plane = plane(item);

      if (item.rigth - item.left > width_th && item.up - item.down > heigth && res_plane < 0.09
          /*&&
          item.item.size() > 20*/
      ) {
        res.push_back(item);
      }
    }
  }

  return res;
}
#endif
inline void Filterate760::highReflectiveInter(OnePointInfoManage760& points, bool single, uint8_t echo_num, uint16_t hor_resolution,
                                              int32_t max_angle) {
  const int loss_point_th = 5;
  auto res = voxelCluster(points, 5, 0.3, 0.3, true, single, echo_num, hor_resolution, max_angle);

  // for (int line = 1; line <= max_line_id; line++) {
  //    for (int angle = 0; angle < max_angle; angle += hor_resolution) {
  //        auto& p = points.getData(1, line, angle);
  //        if (p.line != 0)
  //            p.reflectivity = 0;
  //    }
  //}

  std::vector<std::unordered_map<int, std::vector<OnePointInfo760*>>> line_classification;

  for (size_t i = 0; i < res.size(); i++) {
    std::unordered_map<int, std::vector<OnePointInfo760*>> line_classificationitem;

    for (auto& tem : res[i].item) {
      line_classificationitem[tem->line_id].push_back(tem);
    }

    line_classification.push_back(line_classificationitem);
  }

  for (auto& item : line_classification) {
    for (auto& tem : item) {
      std::sort(tem.second.begin(), tem.second.end(), [](OnePointInfo760* a, OnePointInfo760* b) { return a->hor_azimuth > b->hor_azimuth; });

      OnePointInfo760* last_point = tem.second[0];
      for (auto& p : tem.second) {
        int loss_num = last_point->hor_azimuth - p->hor_azimuth;
        int dis_diff = std::abs((int)((last_point->distance - p->distance) * 1000));
        int dis = (int)((last_point->distance + p->distance) * 1000 / 2);
        int reflectivity = (last_point->reflectivity + p->reflectivity) / 2;
        // int LowPulseWidth = (last_point->LowPulseWidth + p->LowPulseWidth) /
        // 2;/ int tall_pulse_width = (last_point->TallPulseWidth +
        // p->TallPulseWidth) / 2;
        if ((loss_num > hor_resolution) && loss_num < loss_point_th * hor_resolution && dis_diff < 300) {
          for (int start_angle = p->hor_azimuth + hor_resolution; start_angle < last_point->hor_azimuth; start_angle += hor_resolution) {
            int pack_num = start_angle / hor_resolution;
            auto& modify_p = points.getData(echo_num, p->line_id, pack_num);
            float angle = start_angle / 100.0;
            if (modify_p.line_id == 0) {
              uint32 id = create_index(p->echo_type, p->line_id, pack_num);  // Id + k;
              OnePointInfo760 tem;
              tem.index = id;
              tem.line_id = p->line_id;
              tem.rotating_mirror_id = p->rotating_mirror_id;
              float offset_h_angle = getTimeSequenceOffsetHorAngle(p->motor_speed / 100.0, tem.line_id) / 1000.0;
              tem.hor_angle = angle + offset_h_angle + offset_hor_angle_[tem.rotating_mirror_id - 1][pack_num] / 1000.0;
              float vertical = p->device_model != 1 ? (ver_angle_type2_[p->line_id - 1] / 1000.0) : (ver_angle_type1_[p->line_id - 1] / 1000.0);
              tem.ver_angle = vertical + offset_ver_angle_[tem.rotating_mirror_id - 1][pack_num] / 1000.0;

              tem.hor_azimuth = start_angle;
              tem.ver_azimuth = (int16_t)(tem.ver_angle * 100);
              tem.distance = dis / 1000.0;
              tem.reflectivity = reflectivity;
              // tem.LowPulseWidth = LowPulseWidth;
              // tem.TallPulseWidth = tall_pulse_width;
              // tem.EchoType = p->EchoType;
              tem.timestamp = p->timestamp;
              tem.non_filterable = 1;
              float xy = tem.distance * COS(int32_t(tem.ver_angle * 1000));
              tem.x = xy * SIN(int32_t(tem.hor_angle * 1000));
              tem.y = xy * COS(int32_t(tem.hor_angle * 1000));
              tem.z = tem.distance * SIN(int32_t(tem.ver_angle * 1000));
              points.insert(id, std::move(tem));
            } else if (modify_p.distance < 0.001 || std::abs(std::abs(((int)(modify_p.distance * 1000)) - dis) - dis) < 300) {
              // float offset_h_angle =
              // getTimeSequenceOffsetHorAngle(p->motor_speed / 100.0,
              // modify_p.line_id); modify_p.hor_angle = angle + offset_h_angle
              // + offset_hor_angle_[modify_p.rotating_mirror_id - 1][pack_num]
              // / 1000.0; float vertical = p->device_model != 1 ?
              // (ver_angle_type2_[p->line_id - 1] / 1000.0) :
              // (ver_angle_type1_[p->line_id - 1] / 1000.0); modify_p.ver_angle
              // = vertical + offset_ver_angle_[modify_p.rotating_mirror_id -
              // 1][pack_num] / 1000.0;

              // tem.hor_azimuth = start_angle;
              // tem.ver_azimuth = tem.ver_azimuth;
              modify_p.distance = dis / 1000.0;
              modify_p.reflectivity = reflectivity;
              // modify_p.LowPulseWidth = LowPulseWidth;
              // modify_p.TallPulseWidth = tall_pulse_width;
              // modify_p.EchoType = p->EchoType;
              modify_p.timestamp = p->timestamp;
              modify_p.non_filterable = 1;
              float xy = modify_p.distance * COS(int32_t(modify_p.ver_angle * 1000));
              modify_p.x = xy * SIN(int32_t(modify_p.hor_angle * 1000));
              modify_p.y = xy * COS(int32_t(modify_p.hor_angle * 1000));
              modify_p.z = modify_p.distance * SIN(int32_t(modify_p.ver_angle * 1000));
            }
          }
        }
        last_point = p;
      }
    }
  }
}
#endif

inline void Filterate760::replenishPoint(OnePointInfoManage760& points, int dis_th, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle) {
  // const int hor_resolution = 15;
  int max_interval = 1;

  for (int line = 1; line <= 192; line++) {
    OnePointInfo760* last_point = nullptr;
    for (int angle = 0; angle < max_angle; angle += hor_resolution) {
      auto& p = points.getData(echo_num, line, angle / hor_resolution);
      if (p.distance < dis_th || p.distance == 0)
        continue;
      if (last_point == nullptr) {
        last_point = &p;
        continue;
      } else {
        int interval = p.line_id - last_point->line_id - 1;
        if (interval > 0 && interval <= max_interval) {
          if (std::abs(p.distance - last_point->distance) < 1.0) {
            for (int i = 1; i <= interval; i++) {
              int ag = last_point->hor_azimuth + hor_resolution * i;
              auto& tem = points.getData(echo_num, line, ag / hor_resolution);
              if (tem.distance == 0) {
                tem.hor_angle_index = ag / hor_resolution;
                tem.rotating_mirror_id = p.rotating_mirror_id;
                tem.line_id = line;
                tem.device_model = p.device_model;
                float offset_hor_angle = getTimeSequenceOffsetHorAngle(p.motor_speed / 100.0, tem.line_id);
                tem.hor_angle = ag / 100.0 + offset_hor_angle / 1000.0 + offset_hor_angle_[tem.rotating_mirror_id - 1][ag / hor_resolution] / 1000.0f;
                float vertical = ver_angle_type1_[line - 1] / 1000.0;
                tem.ver_angle = vertical + offset_ver_angle_[tem.rotating_mirror_id - 1][ag / hor_resolution] / 1000.0f;

                tem.hor_azimuth = ag;
                tem.ver_azimuth = tem.ver_azimuth;
                tem.distance = (p.distance + last_point->distance) / 2;
                tem.reflectivity = (p.reflectivity + last_point->reflectivity) / 2;
                tem.echo_type = p.echo_type;
                tem.non_filterable = 1;
                float xy = tem.distance * COS(int32_t(tem.ver_angle * 1e3));
                tem.x = xy * SIN(int32_t(tem.hor_angle * 1e3));
                tem.y = xy * COS(int32_t(tem.hor_angle * 1e3));
                tem.z = tem.distance * SIN(int32_t(tem.ver_angle * 1e3));
              }
            }
          }
        }
        last_point = &p;
      }
    }
  }
}

inline void Filterate760::ps_crosstalk_replenish(OnePointInfoManage760& points, uint8_t echo_num, uint16_t hor_resolution, int32_t max_angle) {
  const int check_angle_index[] = {79, 79 + 160, 79 + 160 * 2, 79 + 160 * 3, 79 + 160 * 4, 79 + 160 * 5};
  const int search_range = 30;

  for (int line = 1; line <= 192; line++) {
    for (int angle_index : check_angle_index) {
      auto& p = points.getData(echo_num, line, angle_index);

      {
        int start_angle_index = -1;
        int end_angle_index = -1;
        bool hr = false;
        for (int left_angle_index = angle_index - hor_resolution; left_angle_index > angle_index - search_range; left_angle_index -= 1) {
          auto& p_left = points.getData(echo_num, line, left_angle_index);
          if (p_left.confidence == 1 || p_left.confidence == 2) {
            if (start_angle_index == -1)
              start_angle_index = left_angle_index;
          }
          if (p_left.confidence == 3) {
            hr = true;
            end_angle_index = left_angle_index;
            break;
          }
        }
        if (hr) {
          for (int remove_angle_index = start_angle_index + 1; remove_angle_index < end_angle_index + search_range; remove_angle_index += 1) {
            auto& p_remove = points.getData(echo_num, line, remove_angle_index);
            if (p_remove.reflectivity < 10)
              p_remove.non_filterable = 10;
          }
        }
        start_angle_index = -1;
        end_angle_index = -1;
        hr = false;
        for (int right_angle_index = angle_index + 1; right_angle_index < angle_index + search_range; right_angle_index += 1) {
          auto& p_right = points.getData(echo_num, line, right_angle_index);
          if (p_right.confidence == 1 || p_right.confidence == 2) {
            if (start_angle_index == -1)
              start_angle_index = right_angle_index;
          }
          if (p_right.confidence == 3) {
            hr = true;
            end_angle_index = right_angle_index;
            break;
          }
        }
        if (hr) {
          for (int remove_angle_index = start_angle_index - 1; remove_angle_index > end_angle_index - search_range; remove_angle_index -= 1) {
            auto& p_remove = points.getData(echo_num, line, remove_angle_index);
            if (p_remove.reflectivity < 10)
              p_remove.non_filterable = 10;
          }
        }
      }
    }
  }
}

}  // namespace lidar
}  // namespace vanjee
